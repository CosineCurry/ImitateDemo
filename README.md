# ImitateDemo
理论需要回归到实践，学好一门语言动手能力是不可或缺的。本demo意在自己实现一些java常见的组件来加深自己的理解。
## 2021.9.28 线程安全阻塞队列 MyBlockingQueue
### 使用synchronized关键字
使用synchronized关键字的线程安全的阻塞队列。连个线程并发生产20个数据，2个消费者对此进行消费，耗时长达66s。
耗时过长的原因主要是队列为空时take要休眠200ms，队列满了之后put也要休眠200ms，并且没法被打断，那有没有一种
方法能够让休眠的线程自己能够操作了从而被唤醒，可以用到wait()和notifyAll()进行通知。优化后的阻塞队列对于
上述同样的操作耗时只需73ms！
### 使用显式锁ReentrantLock
我们之前的版本用到这些同步机制：`synchronized(this)`、`this.wait()`、`this.notifyAll()`，这些
同步机制都和当前对象`this`有关。因为`synchronized (obj)`可以使用任意对象对应的对象锁，而`Object.wait()`
和`Object.notifyAll()`方法又都是public方法。也就是说不止在阻塞队列类内部可以使用这个阻塞队列对象的对象锁
及其对应的条件变量，在外部的代码中也可以任意地获取阻塞队列对象上的对象锁和对应的条件变量，那么就有可能发生外
部代码滥用阻塞队列对象上的对象锁导致阻塞队列性能下降甚至是发生死锁的情况。那我们有没有什么办法可以让阻塞队列
在这方面变得更安全呢？
答案是使用显式锁ReentrantLock。
上述同样条件的测试只需67ms。